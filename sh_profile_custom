export LS_OPTIONS='--color=auto'
alias ls='ls $LS_OPTIONS'
alias ll='ls $LS_OPTIONS -lh'
alias l='ls $LS_OPTIONS -lAh'

alias grep="grep --color=auto"
alias fgrep="fgrep --color=auto"
alias egrep="egrep --color=auto"

#if type nerdctl >/dev/null; then
#	alias docker=nerdctl
#	alias docker-compose="nerdctl compose"
#fi

alias csv="sed 's/,/ ,/g' | column -t -s,"

alias reset="reset && printf '\033[2J\033[3J\033[1;1H'"

export LC_CTYPE="en_US.UTF-8"

alias dive='docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock wagoodman/dive:latest'

alias dfimage="docker run --rm -v /var/run/docker.sock:/var/run/docker.sock alpine/dfimage"

alias trivy="docker run --rm -v /var/run/docker.sock:/var/run/docker.sock ghcr.io/aquasecurity/trivy:latest image --scanners vuln --ignore-unfixed"

alias whitespace="sed 's/ /·/g;s/\t/￫/g;s/\r/§/g;s/$/¶/g'"


# STRIP ANSI CHARACTERS SUCH AS COLORS FROM TEE OUTPUT FILE
function teee() {
	type tee &>/dev/null || { echo "The 'tee' command is required for 'teee'"; return 1; }
	tee >(sed $'s/\033[[][^A-Za-z]*[A-Za-z]//g' > $1)
}

if type ts &>/dev/null; then
	alias ts="ts '%Y-%m-%d %H:%M:%.S %Z -'"
fi

# SCAN FOR CREDENTIALS
function gitleaks-scan() {
	config_file=~/.gitleaks/leaky-repo-custom-new.toml
	if [ ! -d .git ]; then
		echo "WARNING: Not in a git directory '$PWD'"
		printf "%s " "Press enter to continue"
		read ans
	fi
	if [ ! -f "${config_file}" ]; then
		echo "Config file not found: ${config_file}"
		return 1
	fi
	echo "Scanning . . ."
	docker run --rm -v "${config_file}:/config.toml" -v "$PWD":/path -w /path ghcr.io/zricethezav/gitleaks:latest detect --config=/config.toml -v --no-git 2>/dev/null | jq -r '.File + "ø" + .Secret + "ø" + .Description' | sort | column -s 'ø' -t | uniq
}

# SCAN IMAGE FOR CREDENTIALS
function image-secret-scanner() {
	IMAGE_SCAN_RESULTS_FILE="image-scan-results.json"
	rm -f "${IMAGE_SCAN_RESULTS_FILE}"
	docker run --rm -v $(pwd):/home/deepfence/output -v /var/run/docker.sock:/var/run/docker.sock deepfenceio/deepfence_secret_scanner:latest --json-filename="${IMAGE_SCAN_RESULTS_FILE}" -image-name $1 >/dev/null
	cat "./${IMAGE_SCAN_RESULTS_FILE}" | jq -r '.Secrets[] | ."Matched Rule Name" + "ø" + .Severity + "ø" + ("/" + ."Full File Name")' | sort | column -s 'ø' -t | uniq
	echo
	echo "-- ENVIRONMENT VARIABLES --"
	docker run --rm $1 env
}


export DOCKER_BUILDKIT=1
export BUILDKIT_PROGRESS=plain
export DOCKER_SCAN_SUGGEST=false

# DE-ANSI CONTENT
function deansi() { cat | sed -r 's/^([0-9]|-|T|:|\.|Z)*\s//' | sed 's/\x1B[@A-Z\\\]^_]\|\x1B\[[0-9:;<=>?]*[-!"#$%&'"'"'()*+,.\/]*[][\\@A-Z^_`a-z{|}~]\|\x1B\][0-9;]*.*\x07//g'; }

# FUNCTION TO ALLOW yq WITHOUT EXTRA ARGS
function yq_disabled() {
	if [[ "$@" == "" ]]; then
		command yq r - -C
	else
		command yq $@
	fi
}

# FUNCTION TO PARSE ANSIBLE LOG TASKS
function ansible-task-parse() {
	if [[ "$1" == "" ]]; then echo "You need to pass a file to parse"; return 1; fi
	if [[ ! -f "$1" ]]; then echo "File not found: $1"; return 1; fi
	cat "$1" \
		| sed 's/\x1b\[[0-9;]*m//g' \
		| grep -E '^TASK|^\w+: \[' \
		| grep -v '^skipping:' \
		| grep -E '^\w+:' -B1 \
		| grep -v '^--$' \
		| grep '^TASK' \
		| grep -v '\(debug\|set_fact\|include_tasks\|include_vars\|fail\)\]' \
		| grep -v '\[include_role' \
		| perl -p -e 's/.*: (.*)\] *.*/\1/' \
		| grep -v '^TASK' \
		| awk '!x[$0]++' \
		| cat -n \
		| sed -r "s/^\s+//g" \
		| sed "s/^[0-9]*/& \> /g"
}

# FUNCTION TO ALLOW WINDOWS WINGET TO RUN IN WSL
command -v winget.exe >/dev/null 2>&1 && { alias winget="winget.exe"; } || true
wingetu() {
	command -v winget.exe >/dev/null || { echo "'winget.exe' not found"; return 1; }
	local upgrade_list_full=$(winget.exe upgrade)
	local TITLE="FULL LIST"
	printf '%*s\n' "$((${COLUMNS:-$(tput cols)}-${#TITLE}-2))" '' | tr ' ' - | perl -p -e "s/^(---)/\1 ${TITLE} /" | perl -p -e "s/^(---)\s\s(-+)/\1\2--/"
	echo -e "${upgrade_list_full}"
	local upgrade_list_filtered=$(echo "${upgrade_list_full}" | tr -d "\r" | grep 'winget$' | perl -p -e 's/^(.*?)\s+([^\s<]+)(?:\s|<)+([^\s]+)\s+([^\s]+)\s+\w+$/\2~\3~\4/' | grep -v '\sUnknown\s' | grep -vE 'Microsoft.VisualStudioCode')
	if [[ "${upgrade_list_filtered}" == "" ]]; then
		echo "Nothing to upgrade"
		return
	fi
	local TITLE="UPGRADABLE LIST"
	printf '%*s\n' "$((${COLUMNS:-$(tput cols)}-${#TITLE}-2))" '' | tr ' ' - | perl -p -e "s/^(---)/\1 ${TITLE} /" | perl -p -e "s/^(---)\s\s(-+)/\1\2--/"
	echo -e "${upgrade_list_filtered}" | sort | column -t -s '~' | sed 's/.*/- &/'
	printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
	while true; do
		printf "Do you want to continue? [Y/n] "
		read yn
		case $yn in
			[Yy]* ) break;;
			[Nn]* ) return 0;;
			* ) echo "Please answer yes or no.";;
		esac
	done
	echo -e "${upgrade_list_filtered}" | awk -F '~' '{print $1}' | xargs -I % sh -c "echo Upgrading: %; winget.exe upgrade -e %;"
}

# FUNCTION THAT EXECUTES COMMANDS WHEN A FILE/DIRECTORY IS MODIFIED
# saveexec /tmp/test.sh
# saveexec /tmp "/test.sh foo bar"
saveexec() {
	if command -v inotifywait >/dev/null; then
		local WATCHER="inotifywait"
	elif command -v fswatch >/dev/null; then
		local WATCHER="fswatch"
	else
		echo "You must install 'inotifywait' for linux or 'fswatch' for macos."
		return 1
	fi
	local SHELL="${SHELL:-$(which sh)}"
	"${SHELL}" -c "env >/tmp/fake.txt"
	local WATCH="$1"
	shift
	ls -ld "${WATCH}" >/dev/null || return 1
	if [ $# -gt 0 ]; then
		local EXEC="$@"
	elif [ -f "${WATCH}" ]; then
		local EXEC="${WATCH}"
	else
		echo "What do you want me to do when this directory is modified?"
		return 1
	fi
	echo -ne "\a"
	clear
	"${SHELL}" -c "${EXEC}" || true
	while true; do
		if [ "${WATCHER}" = "inotifywait" ]; then
			inotifywait --quiet -e modify "${WATCH}"
		elif [ "${WATCHER}" = "fswatch" ]; then
			local MODIFIED="$(fswatch --one-event "${WATCH}")"
		else
			echo "No watcher found"
			return 1
		fi
		echo -ne "\a"
		clear
		sleep 0.1
		"${SHELL}" -c "${EXEC}" || true
	done
}

# FUNCTION TO RUN PRISMA SCAN
prisma() {
	if ! test -f ~/.prisma.conf; then
		echo "Prisma Configuration not found."
		return 1
	fi
	clear
	scan_image="$1" \
	bash -c '
		. ~/.prisma.conf
		#ENCRYPT: echo "username:password" | openssl aes-256-cbc -a -salt -pass pass:"YourEncryptionPasswordHere"
		PRISMA_CREDS=$(echo "${prisma_creds_enc}" | openssl aes-256-cbc -d -a -pass pass:"${prisma_enc}:s@lt")
		PRISMA_USER=$(echo "${PRISMA_CREDS}" | cut -d ":" -f 1)
		PRISMA_PASS=$(echo "${PRISMA_CREDS}" | cut -d ":" -f 2-)
		if [ "${prisma_enc_debug}" == "true" ]; then
			read -p "Debugging enc details. Press enter to continue . . ."
			echo "$PRISMA_USER"
			echo "$PRISMA_PASS"
			exit 0
		fi
		if [[ ! -f /tmp/twistcli ]]; then
			if [ "$(uname -s)" == "Linux" ]; then
				prisma_link="twistcli"
			elif [ "$(uname -s)" == "Darwin" ]; then
				prisma_link="osx/twistcli"
			else
				echo "Unknown platform: $(uname -s)"
				exit 1
			fi
			echo "Downloading twistcli . . ."
			curl -s -u "${PRISMA_USER}":"${PRISMA_PASS}" --output /tmp/twistcli "${prisma_url}/api/v1/util/${prisma_link}"
			echo "done"
		fi
		if [[ "$(docker images -q ${scan_image} 2> /dev/null)" == "" ]]; then
			echo "Pulling image . . ."
			docker pull ${scan_image}
		fi
		chmod 755 /tmp/twistcli
		echo "Scanning . . ."
		/tmp/twistcli images scan --address "${prisma_url}" --user "${PRISMA_USER}" --password "${PRISMA_PASS}" --output-file /tmp/${scan_image}.txt --details ${scan_image}
	'
}

# FUNCTION TO GET COMPILED AZURE PIPELINE YAML
pipeline() {
	display_help() { echo "pipeline <project> <pipeline_id> <branch>"; return; }
	PROJECT="$1"
	PIPELINE_ID="$2"
	BRANCH="$3"
	test -z "${PROJECT}" && { echo "Missing parameter"; display_help; return 1; }
	test -z "${PIPELINE_ID}" && { echo "Missing parameter"; display_help; return 1; }
	test -z "${BRANCH}" && BRANCH="master"
	TMP_FILE="/tmp/test.txt"
	#ENCRYPT: echo "username:password" | openssl aes-256-cbc -a -iter 100000 -salt -pass pass:"YourEncryptionPasswordHere"
	PIPELINE_ENC="$(. ~/.pipeline.conf && echo "${pipeline_enc}")"
	PIPELINE_PAT_ENC="$(. ~/.pipeline.conf && echo "${pipeline_pat_enc}")"
	PIPELINE_CREDS=$(echo "${PIPELINE_PAT_ENC}" | openssl aes-256-cbc -d -a -iter 100000 -pass pass:"${PIPELINE_ENC}:s@lt")
	PIPELINE_CREDS_B64="$(printf "${PIPELINE_CREDS}" | base64 -w 0)"
	curl -sS --request POST \
		--url "https://dev.azure.com/netapp-ngdc/${PROJECT}/_apis/pipelines/${PIPELINE_ID}/preview?api-version=6.1-preview.1" \
		--header "authorization: Basic ${PIPELINE_CREDS_B64}" \
		--header "content-type: application/json" \
		--data '{"previewRun": true, "resources": {"repositories": {"self": {"refName": "refs/heads/'${BRANCH}'"}}}}' \
	>"${TMP_FILE}"
	finalYaml="$(cat "${TMP_FILE}" | jq -r '.finalYaml')"
	if [ "${finalYaml}" = "" ] || [ "${finalYaml}" = "null" ]; then
		cat "${TMP_FILE}"
		echo "THERE WAS AN ERROR"
		return 1
	fi
	echo "${finalYaml}"
}

test -e "${HOME}/.iterm2_shell_integration.bash" && { source "${HOME}/.iterm2_shell_integration.bash"; } || true

# ADDS CUSTOM KUBECONFIG FILES TO CONTEXT
# TO SWITCH CONTEXTS AND NAMESPACES USE https://github.com/ahmetb/kubectx
if test -d ~/.kube; then
	export KUBECONFIG=~/.kube/config
	mkdir -p "$(dirname "$KUBECONFIG")"
	touch "$KUBECONFIG"
	mkdir -p ~/.kube/custom-contexts
	for file in $(find ~/.kube/custom-contexts/ -name '*.config' \( -type f -o -type l \)); do
		file="$(echo "${file}" | sed "s/\/\//\//")" # replace double slashes to single
		export KUBECONFIG="$KUBECONFIG:${file}"
	done
fi

# INSTALL PYENV
	# brew install pyenv
	# pyenv install 2.7.16
	# pyenv versions
	# pyenv global 2.7.16   --- OR --- pyenv local 2.7.16
	# VIRTUAL ENVIRONMENT
	# brew install pyenv-virtualenv
	# pyenv virtualenv 3.6.4 myvirtualenv
	# pyenv global myvirtualenv
if test -d $HOME/.pyenv; then
	export PYENV_ROOT="$HOME/.pyenv"
	export PATH="$PYENV_ROOT/bin:$PATH"
	if command -v pyenv 1>/dev/null 2>&1; then
		eval "$(pyenv init --path)"
	fi
fi

# SET JAVA HOME
if test -f /usr/libexec/java_home; then
	export JAVA_8_HOME=$(/usr/libexec/java_home -v1.8)
	export JAVA_11_HOME=$(/usr/libexec/java_home -v11.0)
	export JAVA_17_HOME=$(/usr/libexec/java_home -v17.0)
	alias java8='export JAVA_HOME=$JAVA_8_HOME'
	alias java11='export JAVA_HOME=$JAVA_11_HOME'
	alias java17='export JAVA_HOME=$JAVA_17_HOME'
	export JAVA_HOME=$JAVA_11_HOME
fi

# WSL EXECUTABLE PATHS
if test -d /mnt/c; then
	export PATH="/mnt/c/Windows/System32:$PATH"
	export PATH="/mnt/c/Users/jonathaf/AppData/Local/Microsoft/WindowsApps:$PATH"
fi

# RANCHER DESKTOP PATHS
if test -d "$HOME/.rd/bin"; then
	export PATH="$HOME/.rd/bin:$PATH"
fi

# NODE PATHS
if test -d $HOME/.npm-packages/bin; then
	export PATH="$HOME/.npm-packages/bin:$PATH"
fi

# SETUP BREW FOR LINUX
if test -f /home/linuxbrew/.linuxbrew/bin/brew; then
	eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
fi

# SETUP BREW FOR macOS Apple Silicon
if test -f /opt/homebrew/bin/brew; then
	eval "$(/opt/homebrew/bin/brew shellenv)"
fi

# SETUP BREW FOR MAC
if type brew &>/dev/null; then
	export PATH="$(brew --prefix)/bin:$PATH"
	export PATH="$(brew --prefix)/opt/mysql-client@5.7/bin:$PATH"
	export PATH="$(brew --prefix)/opt/findutils/libexec/gnubin:$PATH" # USE GNU FIND (must first do: brew install findutils)
	export PATH="$(brew --prefix)/opt/gnu-sed/libexec/gnubin:$PATH" # USE GNU SED (must first do: brew install gnu-sed)
	export PATH="$(brew --prefix)/opt/gnu-tar/libexec/gnubin:$PATH" # USE GNU TAR (must first do: brew install gnu-tar)
	export PATH="$(brew --prefix)/opt/gnu-getopt/bin:$PATH" # USE GNU GETOPT (must first do: brew install getopt)
	export PATH="$(brew --prefix)/opt/coreutils/libexec/gnubin:$PATH" # USE GNU READLINK (must first do: brew install coreutils)
	export PATH="$(brew --prefix)/opt/grep/libexec/gnubin:$PATH" # USE GNU GREP (must first do: brew install grep)
	export PATH="$(brew --prefix)/opt/gnupg@2.2/bin:$PATH" # USE LEGACY GPG
	export PATH="$(brew --prefix)/opt/helm@2/bin:$PATH" # NEED TO RUN 'helm init --client-only' AFTER INSTALLING
	
	alias brewu='brew update; brew upgrade; brew upgrade --cask --greedy'
	alias gnu-grep="$(brew --prefix 2>/dev/null)/opt/grep/libexec/gnubin/grep --color=auto"
fi

export PATH="$HOME/.local/bin:$PATH"


# # FUNCTION TO ALLOW yq WITHOUT EXTRA ARGS
# if type yq &>/dev/null; then
# 	function yq() {
# 		if [[ "$@" == "" ]]; then
# 			if ! type pygmentize &>/dev/null; then
# 				echo "pygmentize not found: pip install Pygments"
# 				return 1
# 			fi
# 			command yq --yaml-output | pygmentize -l yaml
# 		else
# 			command yq $@
# 		fi
# 	}
# fi

if type kubectl &>/dev/null; then
	#alias kubectl="kubectl --insecure-skip-tls-verify"
	alias k="kubectl --insecure-skip-tls-verify"
	if type kubectx &>/dev/null; then
		alias kx="kubectx"
		alias kn="kubens"
	fi
fi

if type velero &>/dev/null; then
	alias v="velero"
fi

if type ansible-playbook &>/dev/null; then
	export ANSIBLE_FORCE_COLOR=True
	# alias ansible-playbook='rm -f $ANSIBLE_LOG_PATH; ansible-playbook'
	# REQUIRED FOR CONJUR IN PLAYBOOKS
	[ "$(uname -s)" = "Darwin" ] && export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES
	[ "${LANG}" = "" ] && export LANG=en_US.UTF-8
fi

test -f ~/.sh_profile_local && { source ~/.sh_profile_local; } || true

# sleep 0.1
# clear
# tpu
